/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   on_expose.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abelov <abelov@student.42london.com>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/25 03:11:20 by abelov            #+#    #+#             */
/*   Updated: 2024/05/25 03:11:21 by abelov           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <assert.h>
#include "fdf/fdf_lib.h"
#include "ft_fdf.h"
#include <math.h>

int draw_circle(t_fdf *fdf, unsigned char *data, int bpp, int sl, int w, int h);
int calc_radius(int x, int y, int w_shift, int h_shift, int raduis);

t_img *im;
/**
 * From the X11 protocol specification
 * (XYFormat):
 *	The data for a pixmap is said to be in XY format if it is organized as
 *	a set of bitmaps representing individual bit planes, with the planes
 *	appearing from most-significant to least-significant in bit order.
 *	Which means for an RGB image you have all the red channel data followed
 *	by the green and then blue instead of the more traditional
 *	RGB triplets (ZPixmap).
 * (ZFormat):
 * 	The data for a pixmap is said to be in Z format if it is organized as
 * 	a set of pixel values in scanline order.
 *	See:
 *		https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html
 */
void ft_draw_pix(t_fdf *fdf, t_cont *ptr, t_img *img)
{
	int size;

	size = ptr->size;
	t_point p;
	t_point *pts = (t_point *)ptr->data;

	int i = -1;
	while(++i < size)
	{
		p = pts[i];
		int offset;
		offset = (img->size_line * p.y) + (p.x * (img->bpp / 8));
		*((unsigned int *)(offset + img->data)) = mlx_get_color_value(fdf->mlx,  p.col);
	}
}

void del_fun(t_cont *ptr)
{
	free(ptr->data);
	free(ptr);
}

typedef struct s_list2	t_list2;
struct s_list2
{
	t_list	*data;
	t_list	*next;
};

/**
 * The XSync function flushes the output buffer and then waits until
 * all requests have been received and processed by the X server.
 * Any errors generated must be handled by the error handler.
 * For each protocol error received by Xlib, XSync calls the client
 * application's error handling routine (see section 11.8.2).
 *
 * Any events generated by the server are enqueued into the library's
 * event queue.
 */
void on_expose(t_fdf *fdf)

{
	t_list *point_list = NULL;
	t_list *point_list2 = NULL;
	t_map_row *row;
	t_point *const t1 = &(t_point){};
	t_point *const t2 = &(t_point){};
	int cr;
	int cc;
	struct s_fdf_win win;
	void	(*f)(void *);
	int z_scale = fdf->z_scale;
	int b_scale = fdf->b_scale;

	int cnt = 0;

	int xpm1_x;
	int xpm1_y;

	t_img *im3 = mlx_new_image(fdf->mlx, fdf->win.width + FT_OFF * 2, fdf->win.height);

	if (!im3) {
		ft_printf(" !! KO !!\n");
		exit(1);
	}
	ft_printf("OK (bpp3 %d, sizeline3 %d endianness3 %d type %d)\n",
			  im3->bpp, im3->size_line, im3->image->byte_order, im3->type);




//	color_screen(im3, 0x0);
//	draw_circle(fdf, im3->data, im3->bpp, im3->size_line, 100, 100);
	t_img *im2 = mlx_xpm_file_to_image(fdf->mlx, "open24.xpm", &xpm1_x, &xpm1_y);
	fdf->canvas = im3;

	win = fdf->win;
	row = fdf->map;
	cr = fdf->rows;
	while (--cr)
	{
		cc = fdf->cols;
		while (--cc)
		{
			cnt++;
			int ch_cc = (int) row->heights[cc] * z_scale;
			int ch_nc = (int) row->heights[(cc - 1)] * z_scale;
			int nh_cc = (int) row->next->heights[cc] * z_scale;
			int nh_nc = (int) row->next->heights[(cc - 1)] * z_scale;

			int cc7 = cc * b_scale * 7;
			int cr7 = cr * b_scale * 7;
			int pc7 = (cc - 1) * b_scale * 7;
			int pr7 = (cr - 1) * b_scale * 7;

			int width = win.width + FT_OFF * 2;
			*t1 = (t_point){
				.x = (cc7 / 10 - cr7 / 10) + width / 2,
				.y = win.height - (ch_cc + cc7 / 20 + cr7 / 20),
				.col = row->colours[cc]};

			t2->x = (pc7 / 10 - cr7 / 10) + width / 2;
			t2->y = win.height - (ch_nc + pc7 / 20 + cr7 / 20);
			t2->col = row->colours[(cc - 1)];

			ft_list_push_front(&point_list, draw_line_d(fdf, *t1, *t2));

			t2->x = (cc7 / 10 - pr7 / 10) + width / 2;
			t2->y = win.height - (nh_cc + cc7 / 20 + pr7 / 20);
			t2->col = row->next->colours[cc];

			ft_list_push_front(&point_list, draw_line_d(fdf,  *t1, *t2));


			if (fdf->custom_colour_flag != 0)
			{
				t2->x = (pc7 / 10 - pr7 / 10) + width / 2;
				t2->y = win.height - (nh_nc + pc7 / 20 + pr7 / 20);
				t2->col = row->next->colours[(cc - 1)];
				ft_list_push_front(&point_list, draw_line_d(fdf, *t1,*t2));
			}

		}
		row = row->next;
	}
	ft_list_foreach(point_list, (void (*)(void *))({
		void lambda_fun(void *data){
			t_list2 *lst =  (t_list2 *)data;
			ft_draw_pix(fdf,(t_cont *)lst->data, im3);
		}
		lambda_fun;
	}));
	ft_list_clear(point_list, (void (*)(void *)) del_fun);
	point_list = NULL;

	mlx_put_image_to_window(fdf->mlx,  fdf->main_win, im3, -FT_OFF, 0);
	mlx_put_image_to_window(fdf->mlx,  fdf->main_win, im2, 0, 0);
}

