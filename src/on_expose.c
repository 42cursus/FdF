/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   on_expose.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abelov <abelov@student.42london.com>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/25 03:11:20 by abelov            #+#    #+#             */
/*   Updated: 2024/05/25 03:11:21 by abelov           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "fdf/fdf_lib.h"
#include "ft_fdf.h"

t_rect	get_rect(t_fdf *fdf, t_map_row *row, int cr, int cc);

/**
 * The XSync function flushes the output buffer and then waits until
 * all requests have been received and processed by the X server.
 * Any errors generated must be handled by the error handler.
 * For each protocol error received by Xlib, XSync calls the client
 * application's error handling routine (see section 11.8.2).
 *
 * Any events generated by the server are enqueued into the library's
 * event queue.
 */
void	on_expose(t_fdf *fdf)
{
	t_map_row	*row;
	t_rect		rect;
	int			cr;
	int			cc;

	row = fdf->map;
	cr = fdf->rows;
	while (--cr)
	{
		cc = fdf->cols;
		while (--cc)
		{
			rect = get_rect(fdf, row, cr, cc);
			draw_line_d(fdf, rect.t1, rect.t2);
			draw_line_d(fdf, rect.t1, rect.t3);
			if (cr == 1)
				draw_line_d(fdf, rect.t3, rect.t4);
			if (fdf->custom_colour_flag)
				draw_line_d(fdf, rect.t1, rect.t4);
		}
		draw_line_d(fdf, rect.t2, rect.t4);
		row = row->next;
	}
	mlx_put_image_to_window(fdf->mlx, fdf->root,
		fdf->canvas, fdf->offset.x, fdf->offset.y);
}

t_rect	get_rect(t_fdf *fdf, t_map_row *row, int cr, int cc)
{
	t_rect	rect;

	rect.t1 = get_point(fdf, row, cc, cr);
	rect.t2 = get_point(fdf, row, cc - 1, cr);
	rect.t3 = get_point(fdf, row->next, cc, cr - 1);
	rect.t4 = get_point(fdf, row->next, cc - 1, cr - 1);
	return (rect);
}

t_point	get_point(t_fdf *fdf, t_map_row *row, int col, int crow)
{
	int		div1;
	int		div2;
	t_point	t1;
	t_point	t2;

	div1 = 10;
	div2 = 15;
	t1.x = col * fdf->xy_scale * fdf->zoom;
	t1.y = crow * fdf->xy_scale * fdf->zoom;
	t1.z = (int)(row->heights[col] * fdf->z_scale * fdf->zoom);
	t2.x = (t1.x / div1 - t1.y / div1) + fdf->win.width / 2
		+ fdf->draw_offset_x;
	t2.y = fdf->win.height - fdf->win.height / 20
		- (t1.z + t1.x / div2 + t1.y / div2) + fdf->draw_offset_y;
	t2.z = t1.z;
	t2.col = row->colours[col];
	return (t2);
}
