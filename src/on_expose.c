/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   on_expose.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abelov <abelov@student.42london.com>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/25 03:11:20 by abelov            #+#    #+#             */
/*   Updated: 2024/05/25 03:11:21 by abelov           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <assert.h>
#include "fdf/fdf_lib.h"
#include "ft_fdf.h"
#include <math.h>

/**
 * From the X11 protocol specification
 * (XYFormat):
 *	The data for a pixmap is said to be in XY format if it is organized as
 *	a set of bitmaps representing individual bit planes, with the planes
 *	appearing from most-significant to least-significant in bit order.
 *	Which means for an RGB image you have all the red channel data followed
 *	by the green and then blue instead of the more traditional
 *	RGB triplets (ZPixmap).
 * (ZFormat):
 * 	The data for a pixmap is said to be in Z format if it is organized as
 * 	a set of pixel values in scanline order.
 *	See:
 *		https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html
 */
void ft_draw_pix(t_fdf *fdf, t_cont *ptr)
{
	t_img *img = fdf->canvas;
	int size;
	char *offset;

	size = ptr->size;
	t_point p;
	t_point *pts = (t_point *)ptr->data;

	int i = -1;
	while(++i < size)
	{
		p = pts[i];
		if ((p.x < 0 ) || (p.y < 0 ))
			continue ;
//		mlx_pixel_put(fdf->mlx, fdf->root, p.x, p.y, p.col);
		offset = img->data + (img->size_line * p.y) + (p.x * (img->bpp / 8));
		*((unsigned int *)(offset)) = p.col;
//		(unsigned int *)(img->data)[offset] = p.col;
	}
}

void del_fun(t_cont *ptr)
{
	free(ptr->data);
	free(ptr);
}

typedef struct s_list2	t_list2;
struct s_list2
{
	t_list	*data;
	t_list	*next;
};

/**
 * The XSync function flushes the output buffer and then waits until
 * all requests have been received and processed by the X server.
 * Any errors generated must be handled by the error handler.
 * For each protocol error received by Xlib, XSync calls the client
 * application's error handling routine (see section 11.8.2).
 *
 * Any events generated by the server are enqueued into the library's
 * event queue.
 */
void on_expose(t_fdf *fdf)

{
	t_list *point_list = NULL;
	t_map_row *row;
	t_point *const t1 = &(t_point){};
	t_point *const t2 = &(t_point){};
	int cr;
	int cc;
	void	(*f)(void *);

	row = fdf->map;

	long height = fdf->draw_offset_y;
	int width = fdf->draw_offset_x;

	cr = fdf->rows;
	while (--cr)
	{
		cc = fdf->cols;
		while (--cc)
		{
			long h1 = row->heights[cc] * fdf->z_scale;
			long h2 = row->heights[(cc - 1)] * fdf->z_scale;

			long h3 = row->next->heights[cc] * fdf->z_scale;

			long h4 = row->next->heights[(cc - 1)] * fdf->z_scale;

			int x1 = cc * fdf->xy_scale * 7;
			int y1 = cr * fdf->xy_scale * 7;

			int x2 = (cc - 1) * fdf->xy_scale * 7;
			int y2 = (cr - 1) * fdf->xy_scale * 7;

			*t1 = (t_point){
				.x = (x1 / 10 - y1 / 10) + width,
				.y = height - (h1 + x1 / 20 + y1 / 20),
				.col = row->colours[cc]};

			t2->x = (x2 / 10 - y1 / 10) + width;
			t2->y = height - (h2 + x2 / 20 + y1 / 20);
			t2->col = row->colours[(cc - 1)];

			ft_list_push_front(&point_list, draw_line_d(fdf, *t1, *t2));

			t2->x = (x1 / 10 - y2 / 10) + width;
			t2->y = height - (h3 + x1 / 20 + y2 / 20);
			t2->col = row->next->colours[cc];

			ft_list_push_front(&point_list, draw_line_d(fdf,  *t1, *t2));

			if (fdf->custom_colour_flag)
			{
				t2->x = (x2 / 10 - y2 / 10) + width;
				t2->y = height - (h4 + x2 / 20 + y2 / 20);
				t2->col = row->next->colours[(cc - 1)];
				ft_list_push_front(&point_list, draw_line_d(fdf, *t1,*t2));
			}

		}
		row = row->next;
	}
	ft_list_foreach(point_list, (void (*)(void *))({
		void lambda_fun(void *data){
			ft_draw_pix(fdf,(t_cont *)data);
		}
		lambda_fun;
	}));
	ft_list_clear(point_list, (void (*)(void *)) del_fun);
	point_list = NULL;

	mlx_put_image_to_window(fdf->mlx, fdf->root, fdf->canvas, fdf->offset.x, fdf->offset.y);
}

