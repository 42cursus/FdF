/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   on_expose.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abelov <abelov@student.42london.com>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/25 03:11:20 by abelov            #+#    #+#             */
/*   Updated: 2024/05/25 03:11:21 by abelov           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <assert.h>
#include "fdf/fdf_lib.h"
#include "ft_fdf.h"
#include <math.h>

/**
 * From the X11 protocol specification
 * (XYFormat):
 *	The data for a pixmap is said to be in XY format if it is organized as
 *	a set of bitmaps representing individual bit planes, with the planes
 *	appearing from most-significant to least-significant in bit order.
 *	Which means for an RGB image you have all the red channel data followed
 *	by the green and then blue instead of the more traditional
 *	RGB triplets (ZPixmap).
 * (ZFormat):
 * 	The data for a pixmap is said to be in Z format if it is organized as
 * 	a set of pixel values in scanline order.
 *	See:
 *		https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html
 */
void ft_draw_pix(t_fdf *fdf, t_cont *ptr)
{
	t_img *img = fdf->canvas;
	int size;
	char *offset;

	size = ptr->size;
	t_point p;
	t_point *pts = (t_point *)ptr->data;

	int i = -1;
	while(++i < size)
	{
		p = pts[i];
		if ((p.x < 0 ) || (p.y < 0 )
			|| (p.x > fdf->canvas->width ) || (p.y > fdf->canvas->height ))
			continue ;
		offset = img->data + (img->size_line * p.y) + (p.x * (img->bpp / 8));
		*(int *)offset = p.col;
//		img->data[(img->size_line * p.y) + (p.x * (img->bpp / 8))] = p.col;
	}
}

void del_fun(t_cont *ptr)
{
	free(ptr->data);
	free(ptr);
}

typedef struct s_list2	t_list2;
struct s_list2
{
	t_list	*data;
	t_list	*next;
};

t_point
get_point(t_fdf *fdf, t_map_row *row, int col, int crow);

/**
 * The XSync function flushes the output buffer and then waits until
 * all requests have been received and processed by the X server.
 * Any errors generated must be handled by the error handler.
 * For each protocol error received by Xlib, XSync calls the client
 * application's error handling routine (see section 11.8.2).
 *
 * Any events generated by the server are enqueued into the library's
 * event queue.
 */
void on_expose(t_fdf *fdf)

{
	t_list *point_list = NULL;
	t_map_row *row;
	t_point t1 = (t_point){};
	t_point t2 = (t_point){};
	t_point t3 = (t_point){};
	t_point t4 = (t_point){};
	int cr;
	int cc;
	void	(*f)(void *);

	row = fdf->map;
	cr = fdf->rows;
	while (--cr)
	{
		cc = fdf->cols;
		while (--cc)
		{
			t1 = get_point(fdf, row, cc, cr);
			t2 = get_point(fdf, row, cc - 1, cr);
			t3 = get_point(fdf, row->next, cc, cr - 1);
			t4 = get_point(fdf, row->next, cc - 1, cr - 1);

			ft_list_push_front(&point_list, draw_line_d(fdf, t1, t2)); // up
			ft_list_push_front(&point_list, draw_line_d(fdf,  t1, t3)); // right
			if (cr == 1)
				ft_list_push_front(&point_list,
								   draw_line_d(fdf, t3, t4)); // down
			if (fdf->custom_colour_flag)
				ft_list_push_front(&point_list, draw_line_d(fdf, t1, t4)); // diag
		}
		ft_list_push_front(&point_list,
						   draw_line_d(fdf, t2, t4)); //left
		row = row->next;
	}

	ft_list_foreach(point_list, (void (*)(void *))({
		void lambda_fun(void *data){ft_draw_pix(fdf,(t_cont *)data);}
		lambda_fun;
	}));
	ft_list_clear(point_list, (void (*)(void *)) del_fun);
	point_list = NULL;

	mlx_put_image_to_window(fdf->mlx, fdf->root, fdf->canvas, fdf->offset.x, fdf->offset.y);
}

void	rotate_x(t_point *point, double angle);
void	rotate_z(t_point *point, double angle);
void	rotate_y(t_point *point, double angle);

t_point get_point(t_fdf *fdf, t_map_row *row, int col, int crow)
{
	t_point t1;
	t_point t2;

	int div1 = 10;
	int div2 = 20;
//	fdf->zoom = 1.5;

	t1.x = col * fdf->xy_scale * 7 * fdf->zoom;
	t1.y = crow * fdf->xy_scale * 7 * fdf->zoom;
	t1.z = (int) (row->heights[col] * fdf->z_scale * fdf->zoom);

	t2.x = (t1.x / div1 - t1.y / div1) + fdf->draw_offset_x;
	t2.y = fdf->draw_offset_y - (t1.z + t1.x / div2 + t1.y / div2);
	t2.z = t1.z;

	t2.col = row->colours[col];
	return (t2);
}


void	rotate_x(t_point *point, double angle)
{
	double	y;
	double	z;

	y = point->y;
	z = point->z;
	point->y = (int)(y * cos(angle) - z * sin(angle));
	point->z = (int)(y * sin(angle) + z * cos(angle));
}

void	rotate_z(t_point *point, double angle)
{
	double	x;
	double	y;

	x = point->x;
	y = point->y;
	point->x = x * cos(angle) - y * sin(angle);
	point->y = x * sin(angle) + y * cos(angle);
}

void	rotate_y(t_point *point, double angle)
{
	double	x;
	double	z;

	x = point->x;
	z = point->z;
	point->x = x * cos(angle) + z * sin(angle);
	point->z = -x * sin(angle) + z * cos(angle);
}